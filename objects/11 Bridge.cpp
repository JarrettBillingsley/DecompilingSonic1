// =====================================================================================================================
// Object 11 - GHZ bridge
// The bridges are made of several objects, one for each log. The way this object works is that it has a "master" log
// which runs all the logic for making the bridge bend down, and all the other logs are separate objects that just
// display a sprite.
//
// Funnily enough, this object supports bridges composed of anywhere from 2 to 15 logs, but the final game only ever
// uses 12-log bridges. I think the coding is a little funny for bridges with odd numbers of logs, but still, it has
// lookup tables for the bending for any length of bridge.
// =====================================================================================================================

enum : ubyte
{
	Routine_Init = 0,
	Routine_Main = 2,
	Routine_StoodOn = 4,
	Routine_Delete = 6,
	Routine_Delete2 = 8,
	Routine_Display = 10,

	initialYW = 0x3C,     // the logs' initial (spawned) Y position, so that the bending can be based off it
	bendAnimDistB = 0x3E, // when Sonic first steps on or steps off bridge, it bends down/up slowly. this controls that
	standingLogB = 0x3F,  // index of the log segment Sonic is standing on
};

enum : ushort
{
	GFX_Bridge = 0x438E,

	Log_Width = 16,
	Log_HalfWidth = Log_Width / 2,
	Log_PlayerOffsY = 8,
	Anim_AngleStep = 4,
	Anim_MaxAngle = 64,
};

const ubyte Map_Bridge[] =
{
	{1, 0xF8, 5, 0, 0, 0xF8}, // log
	{2, 0xF8, 4, 0, 4, 0xF0,  // stump & rope
		0, 0xC, 0, 6, 0xF0},
	{1, 0xFC, 4, 0, 8, 0xF8}, // rope only
};

void Bridge(Object* self)
{
	switch(self->routine)
	{
		case Routine_Init:
			self->routine = Routine_Main;
			self->map = Map_Bridge;
			self->gfx = GFX_Bridge;
			self->render = ObjRender_LayerNormal;
			self->priority = 3;
			self->actWid = 128;

			// Create logs
			auto length = self->subtype;
			auto x = self->x - ((length & 0xFFFE) * Log_HalfWidth); // find position of leftmost log
			self->subtype = 0; // from now on, subtype stores the count of logs actually created
			length -= 2; // -1 for the loop, -1 for self (master log)
			auto logIdx = 0x29;

			for(; length >= 0; length--)
			{
				auto log = FindFreeObj();

				if(log == nullptr)
					break;

				// Successfully allocated new log
				self->subtype++;

				// Are we at the master log position?
				if(x == self->x)
				{
					// If so, just add self to the list before adding the next log
					x += Log_Width;
					VAR_W(self, initialYW) = self->y;
					VAR_B(self, logIdx++) = Object_PointerToSlot(self);
					self->subtype++;
				}

				VAR_B(self, logIdx++) = log;
				log->routine = Routine_Display;
				log->id = self->d;
				log->y = self->y;
				VAR_W(log, initialYW) = self->y;
				log->x = x;
				log->map = Map_Bridge;
				log->gfx = GFX_Bridge;
				log->render = ObjRender_LayerNormal;
				log->priority = 3;
				log->actWid = Log_HalfWidth;
				x += Log_Width;
			}
			// fall through
		case Routine_Main: // this is entered from Routine_StoodOn through ExitPlatform
			Bridge_Main(self);

			// Unbend the bridge if player just left it
			if(VAR_B(self, bendAnimDistB) != 0)
			{
				VAR_B(self, bendAnimDistB) -= Anim_AngleStep;
				Bridge_Bend(self);
			}

			DisplaySprite(self);
			Bridge_CheckOffscreen(self);
			break;

		case Routine_StoodOn: // this is entered through Plat_NoXCheck
			Bridge_StoodOn(self);
			DisplaySprite(self);
			Bridge_CheckOffscreen(self);
			break;

		case Routine_Delete:
		case Routine_Delete2: // presumably Delete2 exists in case Plat_NoXCheck increments the routine from Delete
			DeleteObject(self);
			break;

		case Routine_Display: // logs use this routine
			DisplaySprite(self);
			break;
	}
}

void Bridge_Main(Object* self)
{
	// Check if the player has landed on the bridge
	if(v_player->velY >= 0)
	{
		// I think this calculation is a little off for bridges with an odd number of logs.. seems to check too far left
		// But since the final game only ever uses one size, an even size, it goes unnoticed
		auto diffX = v_player->x - (self->x - ((self->subtype + 1) * Log_HalfWidth));

		if(diffX >= 0 && diffX < self->subtype * Log_Width)
			Plat_NoXCheck(self);
	}
}

void Bridge_StoodOn(Object* self)
{
	int diffX;

	// Check if the player has left the bridge
	if(!ExitPlatform(self, (self->subtype + 1) * Log_HalfWidth, self->subtype * Log_HalfWidth, diffX))
	{
		// If not, figure out which log he's standing on and bend the bridge appropriately
		VAR_B(self, standingLogB) = diffX / Log_Width;

		if(VAR_B(self, bendAnimDistB) != Anim_MaxAngle)
			VAR_B(self, bendAnimDistB) += Anim_AngleStep;

		Bridge_Bend(self);
		Bridge_MoveSonic(self);
	}
}

// Sets Sonic's Y position appropriately so he walks on the sagging bridge
void Bridge_MoveSonic(Object* self)
{
	v_player->y = v_objspace[VAR_B(self, VAR_B(self, standingLogB))]->y - Log_PlayerOffsY - v_player->height;
}

// This controls how far the bridge bends down based on the length of the bridge. Longer bridge = more bending
// First index is length of bridge (in logs), second index is which log player is standing on
const ubyte BendMultiplier[16][16] =
{
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x02, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x02, 0x04, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x02, 0x04, 0x06, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x02, 0x04, 0x06, 0x06, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x02, 0x04, 0x06, 0x08, 0x06, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x02, 0x04, 0x06, 0x08, 0x08, 0x06, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x02, 0x04, 0x06, 0x08, 0x0A, 0x08, 0x06, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0A, 0x08, 0x06, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0A, 0x08, 0x06, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0C, 0x0A, 0x08, 0x06, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00 },
	{ 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x0C, 0x0A, 0x08, 0x06, 0x04, 0x02, 0x00, 0x00, 0x00 },
	{ 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x0E, 0x0C, 0x0A, 0x08, 0x06, 0x04, 0x02, 0x00, 0x00 },
	{ 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x0E, 0x0C, 0x0A, 0x08, 0x06, 0x04, 0x02, 0x00 },
	{ 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x10, 0x0E, 0x0C, 0x0A, 0x08, 0x06, 0x04, 0x02 },
};

// This controls how far the bridge bends down based on which log you're standing on. Closer to center = more bending
// First index is how many logs from the end to this current log; second index is the current log (starting from end)
const byte BendDistance[16][16] =
{
	{ 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0xB5, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x7E, 0xDB, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x61, 0xB5, 0xEC, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x4A, 0x93, 0xCD, 0xF3, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x3E, 0x7E, 0xB0, 0xDB, 0xF6, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x38, 0x6D, 0x9D, 0xC5, 0xE4, 0xF8, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x31, 0x61, 0x8E, 0xB5, 0xD4, 0xEC, 0xFB, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x2B, 0x56, 0x7E, 0xA2, 0xC1, 0xDB, 0xEE, 0xFB, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x25, 0x4A, 0x73, 0x93, 0xB0, 0xCD, 0xE1, 0xF3, 0xFC, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x1F, 0x44, 0x67, 0x88, 0xA7, 0xBD, 0xD4, 0xE7, 0xF4, 0xFD, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x1F, 0x3E, 0x5C, 0x7E, 0x98, 0xB0, 0xC9, 0xDB, 0xEA, 0xF6, 0xFD, 0xFF, 0x00, 0x00, 0x00, 0x00 },
	{ 0x19, 0x38, 0x56, 0x73, 0x8E, 0xA7, 0xBD, 0xD1, 0xE1, 0xEE, 0xF8, 0xFE, 0xFF, 0x00, 0x00, 0x00 },
	{ 0x19, 0x38, 0x50, 0x6D, 0x83, 0x9D, 0xB0, 0xC5, 0xD8, 0xE4, 0xF1, 0xF8, 0xFE, 0xFF, 0x00, 0x00 },
	{ 0x19, 0x31, 0x4A, 0x67, 0x7E, 0x93, 0xA7, 0xBD, 0xCD, 0xDB, 0xE7, 0xF3, 0xF9, 0xFE, 0xFF, 0x00 },
	{ 0x19, 0x31, 0x4A, 0x61, 0x78, 0x8E, 0xA2, 0xB5, 0xC5, 0xD4, 0xE1, 0xEC, 0xF4, 0xFB, 0xFE, 0xFF },
};

// Positions the bridge log segments according to how long the bridge is, where Sonic is standing, and how long he's
// been there.
void Bridge_Bend(Object* self)
{
	auto bendAnimDist = CalcSine(VAR_B(self, bendAnimDistB));
	auto multiplier = BendMultiplier[self->subtype][VAR_B(self, standingLogB)];
	auto bendDist = BendDistance[VAR_B(self, standingLogB)];
	int logIdx = 0x29;

	// Bend down logs to the left of and under player
	for(int i = VAR_B(self, standingLogB), j = 0; i >= 0; i--, j++)
	{
		auto log = v_objspace[VAR_B(self, logIdx++)];
		log->y = (((bendDist[j] + 1) * multiplier * bendAnimDist) >> 16) + VAR_W(log, initialYW);
	}

	auto logsLeft = self->subtype - (VAR_B(self, standingLogB) + 1) - 1;

	if(logsLeft < -1)
		return;

	bendDist = BendDistance[logsLeft + 1];

	// Bend down logs to the right of player
	for(int i = logsLeft, j = logsLeft; i >= 0; i--, j--)
	{
		auto log = v_objspace[VAR_B(self, logIdx++)]
		log->y = (((bendDist[j] + 1) * multiplier * bendAnimDist) >> 16) + VAR_W(log, initialYW);
	}
}

// Delete self if offscreen
void Bridge_CheckOffscreen(Object* self)
{
	if(Object_OutOfRange(self))
	{
		for(int i = self->subtype - 1, j = 0x29; i >= 0; i--, j++)
		{
			auto log = v_objspace[VAR_B(self, j)];

			if(log != self)
				DeleteObject(log);
		}

		DeleteObject(self);
	}
}